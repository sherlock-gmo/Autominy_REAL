#! /usr/bin/env python
import numpy as np
from sklearn.linear_model import RANSACRegressor

ransac = RANSACRegressor()
#**********************************************************************************************************************************
#**********************************************************************************************************************************
#**********************************************************************************************************************************
#**********************************************************************************************************************************
class parking_f():
#**********************************************************************************************************************************	
#**********************************************************************************************************************************
	def __init__(self):
		pass
#**********************************************************************************************************************************	
#**********************************************************************************************************************************
	def fit_ransac(self,X,Y):
		# Toma los puntos en [cm] y les hace una regresion lineal con RANSAC
		L = len(X)
		#print(L)
		X = np.reshape(np.array(X),(L,1))
		Y = np.reshape(np.array(Y),(L,1))
		reg = ransac.fit(X,Y)
		x1 = 0
		x2 = 1
		X_m = np.array([[x1], [x2]]) #np.reshape(np.array([x1, x2]),(2,1))
		y1,y2 = reg.predict(X_m)
		m = (y2-y1)/(x2-x1)
		b = y2-m*x2
		return(m,b)
#**********************************************************************************************************************************	
#**********************************************************************************************************************************
	def steer_control(self,m,b,d_ref):
		Ky = -0.2 #-0.2
		Kth = -9.2 #-9.2
		d = b/np.sqrt(m**2+1)
		e_y = d_ref-d
		e_th = -np.arctan(m)
		u = np.arctan(Ky*e_y+Kth*e_th)*(1.0/(np.pi/2.0)) #unidades normalizadas
		return(u,d)
#**********************************************************************************************************************************	
#**********************************************************************************************************************************
	def parking_type(self,R,side,depth1,depth2):
		# Toma los puntos del lidar en forma cartesiana y detecta si hay espacio para estacionarse
		# Dependiendo de las dimensiones del espacio hace un estacionamiento en paralelo o perpedicular
		p_type = 0
		c1 = 0
		c2 = 0
		i = 0
		for r in R:
			x = r*np.cos(i*(np.pi/180.0))
			y = r*np.sin(i*(np.pi/180.0))
			i = i+1
			if (side == -1):
				lim_inf1 = 0.1
				lim_sup1 = depth1 # 0.45
				lim_inf2 = 0.1
				lim_sup2 = depth2 # 0.55
			else:
				lim_inf1 = -depth1
				lim_sup1 = -0.1
				lim_inf2 = -depth2
				lim_sup2 = -0.1
			# Paralelo
			if (x>=-0.3) and (x<=0.2) and (y>=lim_inf1) and (y<=lim_sup1): c1 = c1+1
			#Perpendicular
			if (x>=-0.2) and (x<=0.1) and (y>=lim_inf2) and (y<=lim_sup2): c2 = c2+1
		if (c1==0): p_type = 1
		if (c2==0) and (c1>0): p_type = 2
		return p_type
#**********************************************************************************************************************************	
#**********************************************************************************************************************************









